#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    pincherDegreeR, sensorPotentiometer)
#pragma config(Sensor, in2,    pincherDegreeL, sensorPotentiometer)
#pragma config(Sensor, in3,    battery2,       sensorAnalog)
#pragma config(Sensor, dgtl7,  encoderArm,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           pincherR,      tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           pincherL,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           armR1,         tmotorVex393_MC29, openLoop, driveRight, encoderPort, dgtl7)
#pragma config(Motor,  port5,           armR2,         tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           armL1,         tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           armL2,         tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port8,           chassisR,      tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl11)
#pragma config(Motor,  port9,           chassisL,      tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl9)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "SmartMotorLib.c"
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*														MARGINAL VALUES 															 */
/*---------------------------------------------------------------------------*/

char autonomousCount;
bool startingLeft;

const char leftButton = 1;
const char centerButton = 2;
const char rightButton = 4;

///For 15 sec autonomous, 8 rubbers
const int armFullCube =90;
const int armFull = 90;
const int armHoldNone = 25;
const int armHoldStar = 42;
const int armHoldCube = 47;
const int armHold3Star = 60;
const int armHoldCubeandStar = 70;

const int turn45 = 130;
const int turn90 = 280;
const int turn180 = 320;

const int pincherLOpen = 1050;
const int pincherROpen = 1050;
const int pincherLMid = 1550;
const int pincherRMid = 1500;
const int pincherLClose = 1950;
const int pincherRClose = 1800;

int gyroAngle;
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*                           BASIC MOVEMENTS                                 */
/*---------------------------------------------------------------------------*/
void armDrive(int armspeed)
{
	motor[armL1] = armspeed;
	motor[armR1] = armspeed;
	motor[armL2] = armspeed;
	motor[armR2] = armspeed;
}

void chassisDrive(int chassisR, int chassisL)
{
	motor[chassisR] = chassisR;
	motor[chassisL] = chassisL;
}

void pincherDrive(int pincherspeed)
{
	motor[pincherL] = pincherspeed;
	motor[pincherR] = pincherspeed;
}
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* 												RESET FUNCTIOINS																	 */
/*---------------------------------------------------------------------------*/
void resetChassisEncoders()
{
	SensorValue[encoderR]=0;
	SensorValue[encoderL]=0;
}

void resetArmEncoder()
{
	SensorValue[encoderArm]=0;
}

int pCalc(int target, tSensors sensorName,float pValue)//change the return value later if this work
{
	int error = abs(target - SensorValue[sensorName]);
	int index = (int)error * pValue;
	if(index > 125)//prevent overshot the motor
	{
		index = 125;
	}
	else
	{
		index = index;
	}

	return index;
}

void gyroSetup()
{
  SensorType[in8] = sensorNone;
  wait1Msec(1000);
  SensorType[in8] = sensorGyro;
  wait1Msec(2000);
  SensorScale[in8] = 140;//#1 Gyro
  /*SensorType[in5] = sensorNone;
  wait1Msec(1000);
  SensorType[in5] = sensorGyro;
  wait1Msec(2000);
  SensorScale[in5] = 131;*/
}

task gyroFilter()
{
  int     gyro_Read;
  int     gyro_Error = 0;
  int     lastDriftGyro = gyroAngle;

  int     angle;
  long    nSysTimeOffset;

  nSysTimeOffset = nSysTime;

  while(true)
  {
  	gyro_Read=SensorValue[in8];
    //if the angle speed smaller than 20/s than consider as a drift
    if( (nSysTime - nSysTimeOffset) > 200 )
      {
        if( abs( gyro_Read - lastDriftGyro ) < 3
        	)
        {
          gyro_Error += (lastDriftGyro - gyro_Read);
        }
        lastDriftGyro = gyro_Read;
        nSysTimeOffset = nSysTime;
      }
      angle = (gyro_Read + gyro_Error)/10;

      //fit the runover
      if(angle< -360)
      {
        angle += 360;
      }
      else if(angle >360)
      {
        angle -= 360;
      }
      else
      {
        angle = angle;
  		}
      gyroAngle = angle; //store the result to global variable;
      wait1Msec(15);
  }
}

void SmartMotorSetUp()
{
	SmartMotorsInit();
	SmartMotorsAddPowerExtender(armR1,armR2,armL1,armL2);
	SmartMotorLinkMotors(armR1,armR2);
	SmartMotorLinkMotors(armR1,armL1);
	SmartMotorLinkMotors(armR1,armL2);
	SmartMotorsSetEncoderGearing(armR1,5.0);
	SmartMotorCurrentMonitorEnable();
	SmartMotorRun();
}
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* 													AUTONOMOUS BASIC     														 */
/*---------------------------------------------------------------------------*/
void gyroTurn(int nDegree,int timeLimit)
{
	int error;
  float index;
	int preError = gyroAngle - nDegree;
	int derivative;
  clearTimer(T2);
  while(time1[T2]<timeLimit)
  {
    error = gyroAngle - nDegree;
    derivative = error-preError;
    preError = error;
    index = 2*error+5.8*derivative;

  	if(index > 120)//prevent overshot the motor
		{
		index = 120;
		}
		else if(index<-120)
		{
			index = -120;
		}
		else
		{
		index = index;
		}
    motor[chassisL] = index;
    motor[chassisR] = -index;
    wait1Msec(25);
  }
  motor[chassisL] = 0;
  motor[chassisR] = 0;
}

void gyroAdjustment(int nDegree)//counterclockwise is postive
{
  int error;
  float index;
  int intergrate=0;
  clearTimer(T1);
  while(time1[T1]<800)
  {
    error = abs(gyroAngle - nDegree);
    intergrate +=error;
    index = 16*error + 0.1*intergrate;
    if(index>30)
    	index = 30;
   	else
   		index = index;
   if(gyroAngle>nDegree)
   {
    motor[chassisL] = index;
    motor[chassisR] = -index;
 		}
 		else if(gyroAngle<nDegree)
 		{
 		motor[chassisL] = -index;
    motor[chassisR] = index;
 		}
 		else
 		{
 		motor[chassisL] = 0;
    motor[chassisR] = 0;
  	}
    wait1Msec(25);
  }
  motor[chassisL] = 0;
  motor[chassisR] = 0;
}

void pidStraight(bool forward,bool ifLift,bool ifHoldPincher,int target)
{
	float kPL;
	float kPR;
	float kIL;
	float kIR;
	float kDL;
	float kDR;
	float indexR=0.0;
	float indexL=0.0;
	int integralLimit;
	if(target>=1200)
	{
		kPL = 0.3*1.3;
		kPR = 0.3;
		kIL = 0.00005;
		kIR = 0.00005;
		kDL = 1.5;
		kDR = 1.5;
		integralLimit = 80;
	}

	else if(500<= target <1200)
	{
		kPL = 0.35*1.2;
		kPR = 0.35;
		kIL = 0.00005;
		kIR = 0.00004;
		kDL = 1;
		kDR = 1;
		integralLimit = 50;
	}
	else
	{
		kPL = 0.4*1.2;
		kPR = 0.4;
		kIL = 0.00006;
		kIR = 0.00006;
		kDL = 1;
		kDR = 1;
		integralLimit = 50;
	}

	int errorL;
	int preErrorL = target;
	int integralL =0;
	int derivativeL;
	int errorR;
	int preErrorR = target;
	int integralR =0;
	int derivativeR;

	char lowSpeedCountL=0;
	char lowSpeedCountR=0;

	resetChassisEncoders();
	clearTimer(T3);

	while((time1[T3]<5000) && ((abs(SensorValue[encoderR])) < target) || ((abs(SensorValue[encoderL]))< target))
	{
		errorL = target - abs(SensorValue[encoderL]);
		errorR = target - abs(SensorValue[encoderR]);

		integralL += errorL;
		integralR += errorR;

		if(abs(errorL) < integralLimit)
		{
			integralL = 0;
		}

		if(abs(errorR) < integralLimit)
		{
			integralR = 0;
		}

		derivativeL = errorL - preErrorL;
		derivativeR = errorR - preErrorR;

		preErrorL = errorL;
		preErrorR = errorR;


		indexL = kPL*errorL + kIL*integralL + kDL*derivativeL;
		indexR = kPR*errorR + kIR*integralR + kDR*derivativeR;

		if(errorR < 100 && indexR < 20)
		{
			lowSpeedCountR++;
		}

		if(errorL < 100 && indexL <20)
		{
			lowSpeedCountL++;
		}
		if(lowSpeedCountL>5 || lowSpeedCountR>5)
			break;

		if(indexR > 125)//prevent overshot the motor
		{
			indexR = 125;
		}
		else
		{
			indexR = indexR;
		}

		if(indexL > 125)
		{
			indexL = 125;
		}
		else
		{
			indexL = indexL;
		}

		if(forward)
		{
			if(lowSpeedCountR<8)
				motor[chassisR]=indexR;
			if(lowSpeedCountL<8)
				motor[chassisL]=indexL;
		}
		else
		{
			if(lowSpeedCountR<8)
				motor[chassisR]=-indexR;
			if(lowSpeedCountL<8)
				motor[chassisL]=-indexL;
		}

		if(ifLift && errorR <180)
		{
			armDrive(125);
		}

		if(ifHoldPincher)
		{
			pincherDrive(20);
		}
		wait1Msec(25);
	}
	motor[chassisR]=0;
	motor[chassisL]=0;
}

void autoOpenPincher()
{
	while(SensorValue[pincherDegreeL] > pincherLOpen  || SensorValue[pincherDegreeR] > pincherROpen)
	{
		int openIndexL = pCalc(pincherLOpen, pincherDegreeL, 0.8);
		int openIndexR = pCalc(pincherROpen, pincherDegreeR,0.8);

		if(openIndexL < 20 || openIndexR <20)
		{
			break;
		}

		if(SensorValue[pincherDegreeL] > pincherLOpen)
		{
			motor[pincherL] = -openIndexL;
		}

		if(SensorValue[pincherDegreeR] > pincherROpen)
		{
			motor[pincherR] = -openIndexR;
		}
	}
	pincherDrive(0);
}

void autoClosePincher()
{
	int preReadL = 1450;
	int preReadR = 1450;
	int speedL;
	int speedR;
	int currentReadL;
	int currentReadR;
	char achievedCountL =0;
	char achievedCountR =0;
	clearTimer(T4);
	while(time1[T4]<800 &&(SensorValue[pincherDegreeL] < pincherLClose || SensorValue[pincherDegreeR] < pincherRClose))
	{
		currentReadL = SensorValue[pincherDegreeL];
		currentReadR = SensorValue[pincherDegreeR];

		speedL = abs(currentReadL - preReadL);
		speedR = abs(currentReadR - preReadR);

		if(SensorValue[pincherDegreeL] < pincherLClose)
		{
			if(speedL>7)
			{
				motor[pincherL] =125;
			}
			else
			{
				achievedCountL++;
				motor[pincherL] = 0;
			}
		}
		else
		{
			motor[pincherL] = 0;
		}

		if(SensorValue[pincherDegreeR] < pincherRClose)
		{
			if(speedR>7)
			{
				motor[pincherR] =125;
			}
			else
			{
				achievedCountR++;
				motor[pincherR] = 0;
			}
		}
		else
		{
			motor[pincherR] = 0;
		}

		if(achievedCountL >1 && achievedCountR >1)
		{
			break;
		}
		preReadL = currentReadL;
		preReadR = currentReadR;
		wait1Msec(25);
	}
	pincherDrive(0);
}

void midPincher()
{
	int indexR;
	int indexL;
	clearTimer(T2);
	while((time1(T2)<700) && (((pincherLMid-5)<SensorValue[pincherDegreeL] <(pincherLMid+5))  || ((pincherRMid-5)<SensorValue[pincherDegreeR] <(pincherRMid+5))))
	{
    if(SensorValue[pincherDegreeR]<(pincherRMid-5))
    {
    	indexR = pCalc(pincherRMid, pincherDegreeR,0.1);
      motor[pincherR] = indexR;
    }
    else if(SensorValue[pincherDegreeR] > (pincherRMid+5))
    {
    	indexR = pCalc(pincherRMid, pincherDegreeR,0.1);
      motor[pincherR] = - indexR;
    }
   	else
   		motor[pincherR] =0;

    if(SensorValue[pincherDegreeL]< (pincherLMid-5))
    {
    	indexL = pCalc(pincherLMid, pincherDegreeL, 0.1);
      motor[pincherL] = indexL;
    }
    else if(SensorValue[pincherDegreeL] > (pincherLMid+5))
    {
    	indexL = pCalc(pincherLMid, pincherDegreeL, 0.1);
      motor[pincherL] = - indexL;
    }
    else
    	motor[pincherL] = 0;
	}
  pincherDrive(0);
}

void releasePincher()//6 each side
{
	clearTimer(T3);
	while(time1[T3]<150)
	{
  pincherDrive(-125);
	}
	pincherDrive(0);
}


void autoArmDown()
{
	while(abs(SensorValue[encoderArm])>20)
	{
		armDrive(-80);
	}
	armDrive(0);
}

void autoArmDownSpec()
{
	while(abs(SensorValue[encoderArm])>3)
	{
		armDrive(-100);
	}
	armDrive(0);
}

void autoArmUp(char type)
{
	int mv_armUp;
	switch(type)
	{
	case 1:
		 mv_armUp= armFull;
		break;
	case 2:
		mv_armUp = armFullCube;
		break;
	}
	while(abs(SensorValue[encoderArm])<mv_armUp)
	{
		//pincherDrive(20);
		armDrive(125);
	}
	armDrive(0);
}

void autoArmHold(char type)
{
	int mv_armHold;

	switch(type)
	{
		case 0:
		mv_armHold = armHoldNone;
		break;
		case 1:
	 	mv_armHold= armHoldStar;
		break;
		case 2:
		mv_armHold = armHoldCube;
		break;
		case 3:
		mv_armHold = armHold3Star;
		break;
		case 4:
		mv_armHold = armHoldCubeandStar;
	}

	while(abs(SensorValue[encoderArm])<mv_armHold)
	{
		armDrive(70);
		wait1Msec(25);
	}
	armDrive(0);
}

void midArm()
{
	while(abs(SensorValue[encoderArm])> 45)
	{
		armDrive(-100);
		wait1Msec(25);
	}
	armDrive(0);
}

void flashLED(int n)
{
	for(int i=0; i<n; i++)
			{
			bLCDBacklight=true;
			wait1Msec(500);
			bLCDBacklight=false;
			wait1Msec(500);
			}
}
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* 													Driver Control    															 */
/*---------------------------------------------------------------------------*/
task openPincher()
{
	while(SensorValue[pincherDegreeL] > pincherLOpen  || SensorValue[pincherDegreeR] > pincherROpen)
	{
		int openIndexL = pCalc(pincherLOpen, pincherDegreeL, 0.7);
		int openIndexR = pCalc(pincherROpen, pincherDegreeR,0.7);

		if(openIndexL < 20 || openIndexR <20)
		{
			break;
		}

		if(SensorValue[pincherDegreeL] > pincherLOpen)
		{
			motor[pincherL] = -openIndexL;
		}

		if(SensorValue[pincherDegreeR] > pincherROpen)
		{
			motor[pincherR] = -openIndexR;
		}
	}
	pincherDrive(0);
}

task closePincher()
{
	int speedL;
	int speedR;
	int preReadL = 800;
	int preReadR = 800;
	int currentReadL;
	int currentReadR;
	int achievedCountL =0;
	int achievedCountR =0;

	while(SensorValue[pincherDegreeL] < pincherLClose || SensorValue[pincherDegreeR] < pincherRClose)
	{
		currentReadL = SensorValue[pincherDegreeL];
		currentReadR = SensorValue[pincherDegreeR];

		speedL = abs(currentReadL - preReadL);
		speedR = abs(currentReadR - preReadR);

		if(SensorValue[pincherDegreeL] < pincherLClose)
		{
			if(speedL>1)
			{
				motor[pincherL] =125;
			}
			else
			{
				achievedCountL++;
				motor[pincherL] = 0;
			}
		}
		else
		{
			motor[pincherL] = 0;
		}

		if(SensorValue[pincherDegreeR] < pincherRClose)
		{
			if(speedR>1)
			{
				motor[pincherR] =125;
			}
			else
			{
				achievedCountR++;
				motor[pincherR] = 0;
			}
		}
		else
		{
			motor[pincherR] = 0;
		}

		if(achievedCountL >1 && achievedCountR >1)
		{
			break;
		}
		preReadL = currentReadL;
		preReadR = currentReadR;
		wait1Msec(25);
	}
	pincherDrive(0);
}
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* 													AUTONOMOUS PLANS    														 */
/*---------------------------------------------------------------------------*/
void autonomousA1()
{
	if(startingLeft)
	{
		releasePincher();
		wait1Msec(300);
		pidStraight(false,false,false,200);
		pidStraight(true,false,false,1300); // Drive straight to the far star cluster//900
		wait1Msec(100);
		autoClosePincher(); // Close pincher aroudn the star cluste
		pidStraight(false,false,true,1100); // Drive back to starting posistion
		autoArmHold(3);
    gyroTurn(-90,900);
    pidStraight(false,false,true,500);
    autoArmDown();
		pidStraight(false,true,true,850); // Move backwards to the fence
		autoArmUp(1);
		autoOpenPincher();
		autoArmDown();
	}
	else
	{
	}
}

void autonomousA2()
{
	if(startingLeft)
	{
		releasePincher();
		wait1Msec(250);
		pidStraight(false,false,false,200);
		pidStraight(true,false,false,825); // Drive straight to the far star cluster
		autoClosePincher(); // Close pincher aroudn the star cluste
		wait1Msec(50);
		pidStraight(false,false,true,675); // Drive back to starting posistion
		autoArmHold(2);
	  gyroTurn(-90,700);
		pidStraight(false,false,true,1350); // Move backwards to the fence
		autoArmUp(1);
		autoOpenPincher();
		autoArmDown();
		gyroTurn(-25,700);
		autoOpenPincher();
		pidStraight(true,false,false,700);
		autoClosePincher();
		pidStraight(false,true,true,675);
		autoArmUp(2);
		autoOpenPincher();
	}
	else
	{
	}
}

void autonomousNULL()
{
	releasePincher();
}

void autonomousB1()
{
	if(startingLeft)
	{
	releasePincher();
	wait1Msec(200);
	autoOpenPincher();
	pidStraight(true,false,false,650);
	autoClosePincher();
	autoClosePincher();
	autoArmHold(2);
	gyroTurn(-110,1000);
	autoClosePincher();
	pidStraight(false,true,true,700);
	autoArmUp(2);
	autoOpenPincher();
	autoArmDown();
	}
	else
	{
	}
}

void autonomousB2()
{
		if(startingLeft)
	{
	releasePincher();
	wait1Msec(200);
	autoOpenPincher();
	pidStraight(true,false,false,900);//increase to push the cube
	autoClosePincher();
	autoClosePincher();
	autoArmHold(2);
	gyroTurn(-130,1000);
	pidStraight(false,true,true,800);
	autoArmUp(2);
	autoOpenPincher();
	autoArmDown();
	pidStraight(true,false,false,850);
	autoClosePincher();
	pidStraight(false,true,true,850);
	autoArmUp(1);
	autoOpenPincher();
	}
	else
	{
	}
}

void autonomousC()
{
	releasePincher();
	wait1Msec(500);
	autoOpenPincher();
	autoArmHold(0);
	pidStraight(true,false,false,1100);
}

/*---------------------------------------------------------------------------*/
/* 													AUTONOMOUS SELECTION 														 */
/*---------------------------------------------------------------------------*/
void waitForPress()
{
	while(nLCDButtons == 0)
  {
  }
	wait1Msec(5);
}

void waitForRelease()
{
	while(nLCDButtons != 0)
  {
  }
	wait1Msec(5);
}

void displayMenu()
{
	displayLCDString(1,1,"<");
	displayLCDString(1,7,"RUN");
	displayLCDString(1,14,">");
}

void lcdSelection() //Selection Menu for LCD
{
	  int selectionCount = 0;//Declare count variable to keep track of our choice
		bLCDBacklight = true;
		//------------- Beginning of User Interface Code ---------------
		clearLCDLine(0);
		clearLCDLine(1);
    displayLCDCenteredString(0,"StartingPosition");
	  displayLCDString(1,0,"Left");
	  displayLCDString(1,11,"Right");
	  while(nLCDButtons != rightButton || nLCDButtons != leftButton)
	  {
	    waitForPress();
	    if(nLCDButtons == leftButton)
	    {
	      waitForRelease();
	      startingLeft = true;
	      break;
	    }
	    else if(nLCDButtons == rightButton)
	    {
	      waitForRelease();
	      startingLeft = false;
	      break;
	    }
	    wait1Msec(50);
	  }

    clearLCDLine(0);
    clearLCDLine(1);
		//Loop while center button is not pressed
		while(nLCDButtons != centerButton)
		{
			switch(selectionCount)
      {
			case 0:
				//Display first choice
				clearLCDLine(0);
				displayLCDCenteredString(0, "A1");
				clearLCDLine(1);
				displayMenu();
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectionCount = 4;//related to total autonomous selection
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectionCount++;
				}
				break;
			case 1:
				//Display second choice
				clearLCDLine(0);
				displayLCDCenteredString(0, "NULL");
				clearLCDLine(1);
				displayMenu();
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectionCount--;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectionCount++;
				}
				break;

				case 2:
						clearLCDLine(0);
						displayLCDCenteredString(0, "B1");
						clearLCDLine(1);
						displayMenu();
						waitForPress();
						//Increment or decrement "count" based on button press
						if(nLCDButtons == leftButton)
						{
							waitForRelease();
							selectionCount--;
						}
						else if(nLCDButtons == rightButton)
						{
							waitForRelease();
							selectionCount ++;
						}
						break;

					case 3:
					clearLCDLine(0);
					displayLCDCenteredString(0, "B2");
					clearLCDLine(1);
					displayMenu();
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						selectionCount--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						selectionCount ++;
					}
					break;

					case 4:
					clearLCDLine(0);
					displayLCDCenteredString(0, "C");
					clearLCDLine(1);
					displayMenu();
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						selectionCount--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						selectionCount =0;
					}
					break;
		}
	}

    autonomousCount = selectionCount; //asign the final result to global variable
} // Ends function lcdSelection

void lcdSetUp()
{
  flashLED(3);
	float mainBattery;
	float secondBattery;
  bool batteriesChecked = false;
  bool gyroSetuped = false;
  string StartingSide;
  if(startingLeft)
	{
		StartingSide = "L";
	}
	else
	{
		StartingSide = "R";
	}
	mainBattery = nImmediateBatteryLevel / 1000.0;
	secondBattery = SensorValue[battery2]/280.0;

	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = false;

	if(mainBattery > 8.1)
	{
		displayLCDString(0,0,"Main:Checked");
    batteriesChecked = true;
	}
	else
	{
		displayLCDString(0,0,"Main: Replace!");
	}

	if(secondBattery > 8.1)
	{
		displayLCDString(1,0,"Second:Checked");
	}
	else
	{
		displayLCDString(1,0,"Second: Replace!");
    batteriesChecked = false;
	}
	bLCDBacklight=true;
  waitForPress();
  SmartMotorSetUp();
  clearLCDLine(0);
  clearLCDLine(1);
  displayLCDCenteredString(0,"Motors Smart");

  wait1Msec(500);
  clearLCDLine(0);
  clearLCDLine(1);
  displayLCDCenteredString(0,"SettingUp Gyro");
  wait1Msec(1000);//wait the robot to stablize
  gyroSetup();
  gyroSetuped = true;
	clearLCDLine(0);

  while(bIfiRobotDisabled)
  {
    if(batteriesChecked && gyroSetuped)
    {
      displayLCDCenteredString(0,"B&G Ready");
    }
    else if(gyroSetuped)
  	{
  		displayLCDCenteredString(0,"Gyro Ready");
  	}
  	else
  	{
  		displayLCDCenteredString(0,"SetUp Failed");
  	}

    switch(autonomousCount)
    {
      case 0:
      displayLCDString(1,2,StartingSide);
      displayLCDString(1,5,"A1 Ready");
      break;
      case 1:
      displayLCDString(1,2,StartingSide);
      displayLCDString(1,5,"NULL Ready");
      break;
			case 2:
      displayLCDString(1,2,StartingSide);
      displayLCDString(1,5,"B1 Ready");
      break;
			case 3:
      displayLCDString(1,2,StartingSide);
      displayLCDString(1,5,"B2 Ready");
      break;
			case 4:
      displayLCDString(1,2,StartingSide);
      displayLCDString(1,5,"C Ready");
      break;
    }
  }
}

void lcdExecution()
{
	bLCDBacklight=false;
	switch(autonomousCount)
  {
		case 0:
    autonomousA1();
    break;
    case 1:
    autonomousNULL();
    break;
    case 2:
    autonomousB1();
    break;
    case 3:
    autonomousB2();
    break;
    case 4:
    autonomousC();
    break;

  }
}
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*---------------------------------------------------------------------------*/
void pre_auton()
{
  bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;
	lcdSelection();
	lcdSetUp();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                       		 */
/*---------------------------------------------------------------------------*/

task autonomous()
{
  // ..........................................................................
  startTask(gyroFilter);
	lcdExecution();
  // ..........................................................................

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	while(true) // Space between while (true) deleted
	{
		SetMotor(chassisR,vexRT[Ch2]);
		SetMotor(chassisL,vexRT[Ch3]);

		if(vexRT[Btn6U] ==1)
		{
			stopTask(closePincher);
			armDrive(125);
		}

		else if(vexRT[Btn6D]==1)
		{
			armDrive(-100);
		}

		else
		{
			armDrive(0);
		}

		if(vexRT[Btn5U] ==1)
		{
			stopTask(openPincher);
			startTask(closePincher);
		}

		else if(vexRT[Btn5D]==1)
		{
			stopTask(closePincher);
			startTask(openPincher);
		}
		else
		{
			pincherDrive(0);
		}
	}
}
